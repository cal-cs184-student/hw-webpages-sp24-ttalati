<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS 184 Homework 4, 
Tanush Talati</title>
    <style>
	.left {
		text-align: left;
	}
        .caption {
            text-align: center;
            font-style: italic;
        }
        .im-container { 
            justify-content: space-between; 
            margin-bottom: -10px;
            flex-wrap: wrap;
            text-align: center;
        }
        .label {
            text-align: center;
        }
        .image-container {
            width: 70%;
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 20px;
            text-align: center;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .image {
            width: 100%;
            margin-bottom: -10px;
        }
        footer {
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            bottom: 0;
            width: 100%;
        }
        h1, h2, h3, h4, h5, h6 {
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <header>
        <h1>CS 184 Homework 4: ClothSim</h1>
        <h2> 
Tanush Talati </h2>
    </header>
    
    <div class="container">
        <h2>Overview</h2>

	<p>
	In this assignment, I implemented a real-time cloth simulator, which relied on a spring-mass based system to physically simulate the movement of physical objects such as cloth. The assignment was split into five parts.
	</p>

	<p>The first part required us to actually build out the grid of springs and masses that represent the cloth. This meant connecting neighboring masses with springs to represent shearing, structural, and bending constraints. Such connections are meant to help get realism into the cloth movement. 
	</p>

	<p>
	In the second part, the structure of connections that were formed was leveraged to actually implement the machinery that would determine the location of the different point masses at different time periods. In other words, it dealt with implementing the simulation component. To do this, first I had to calculate the total force acting on a particular mass. This would be the sum of all the different enabled constraint forces acting on the spring. Next we had to utilize verlet integration, a method to approximate dynamics governed by differential equations to deduce the location and velocity of the point mass at the next time step. Since this method of simulation is unstable in nature, the final step involved bounding the distance of a point mass away from its rest position, which was simply done by checking if it was more that 10% away from its rest position and if it was, we would manually adjust the position to be at the threshold mark.
	</p>
    <p>
	    The third part helped implement a collision detection and handling system. Basically the second part gave a working simulator when only one object existed in the world but with multiple objects, we need to make sure that objects do not go through each other and hence need to detect collisions, because if they occur we can adjust the location of the mass to stay above the collided surface. We only dealt with collisions against two different objects: spheres and planes. The only difference between the two was the process in determining if a collision occurred due to the different geometry of the two surfaces. But after that, if a collision occurred, in both cases a correction vector, allowing the object to stay slightly above the collided point was applied and the new position would be this position scaled by 1 - frictional force.
    </p>
    
    <p>
  The fourth part dealt with self-collisions. This would allow the simulation to exhibit complex geometry such as folding on itself when the cloth is dropped for instance. This was implemented by first creating a hashmap where all masses within a rectangular-prism volume would get hashed into the same key and the value would be a list of the objects in the same volume. Once the hashing was done and all the point masses were placed in their respective arrays, we would compare all the pointmasses inside the respective arrays. If two were within some threshold distance, (2 * thickness), a correction vector would be applied to the two point masses to get them at this threshold distance apart (creating spacing). Due to the possibility of multiple masses being this close, the final correction would just be the average of all the corrections on the point mass. 
    </p>

<p>
The last part was a bit different, it had us implement shaders, a quick way to introduce and implement shading schemes that is relatively computationally cheap. Multiple shaders were implemented. First we started with the basic diffuse shading, where light is reflected equally in all directions. Then, more complex versions were implemented, namely the blinn-phong shading model, texture mapping, displacement and bump-mapping, and environment mapped reflections.
</p>
	    
        <section>
            <h3>Part 1: Masses and Springs</h3>
            
            
            <p>In this part the grid of point masses and the springs that interconnect the various point masses was implemented. This spring-mass representation of the cloth allows us to simulate physics that is used to approximate and simulate realistic cloth movement. The cloth was parameterized by num_width_points and num_height_points, representing the number of masses along the width and height of the cloth respectively. The third dimension was either set to 1 or a random number between -1/1000 and 1/1000 depending on the plane the cloth existed in. Furthermore if a cloth point mass was pinned, hence it would not be moving, that was set as well with a boolean flag.           
            </p>

		<p>Once the grid of point masses was constructed, springs defining the interconnections between the point masses were created. There were three types of spring, representing different constraints: structural, shearing, and bending. Depending on the type of constraint, the spring connected different point masses according to how it was detailed out the spec. Once these mainly bookmarking implementations were complete, a mesh of connections could be seen. These meshes are shown below.
            </p>

		<p>Below is the cloth wireframe showing all the connections both bending and steady behavior.        
            </p>

	    <div class='im-container'>
                <div>
                <div class="label"> Grid-View </div>
                <img class="image-container" src="grid.png" alt="iter0">
                </div>
                <div>  
                <div class="label"> Showing the bending </div>    
                <img class="image-container" src="bending.png" alt="iter1">
                </div>
            </div>

	<p class="caption">Showing the grid view with all three constraints, representing working connection of point-masses using springs.
</p>
<p class="left">
		Now I just show some of the constraints individually.
	</p>

		 <div class='im-container'>
                <div>
                <div class="label"> All Three Constraints </div>
                <img class="image-container" src="three.png" alt="iter0">
                </div>
                <div>  
                <div class="label">Only Shearing Constraints </div>    
                <img class="image-container" src="shearing.png" alt="iter1">
                </div>
		 <div> 
		<div class="label">No Shearing (Bending and Structural) </div>    
                <img class="image-container" src="noshearing.png" alt="iter1">
                </div>
            </div>
			<p class="caption">Showing the connections when turning off some contraints the the view.
</p>
        </section>
        
        <section>
            <h3>Part 2: Simulation via Numerical Integration </h3>
            <p> This section enabled actual cloth simulation. Basically the positions at the next time step, calculated by taking into account the forces exerted on each of the point-masses at the current time-step were calculated using verlet integration. Specifically since the system consists of a lot of interconnected springs, each point mass would have forces being exerted on it by these springs, which can be found out through Hooke’s law. Then applying the rules of dynamics, we know acceleration, mass, and force are related by F = ma, allowing us to find the acceleration and its direction by dividing the force by the mass of the point. Then we can use the equations given my verlet integration to find the new point location of the mass. Doing this point-mass location calculation for all of the pointmasses would help move the grid and give the new position of the cloth. Essentially the new position was calculated as follow x_new = x_old + v_curr * time + a_curr * time^2. And v_curr * time was simply estimated as x_curr - x_old. The exact quantity of time is also dependent on the number of simulation steps per frame and the number of frames per second. Finally since this method of approximation is not stable, we physically bounded the values x could take on. Specifically x could only be at most 10% off its rest position. This would make clothes act more realistically as we know usually it does not move out of place by a large amount.  
	    </p>

		<p>Below are photos showing a working implementation of the cloth simulation, manipulating some of the variables that control the dynamics. 
		</p>

	<div class='im-container'>
                <div>
                <div class="label"> No change default </div>
                <img class="image-container" src="default.png" alt="iter0">
                </div>
            </div> 

		<p class='left'>
		First we change k_s.	
		</p>
       
		<div class='im-container'>
                <div>
                <div class="label"> k_s = 100 N/m </div>
                <img class="image-container" src="100.png" alt="iter0">
                </div>
                <div>  
                <div class="label"> k_s = 10,000 N/m </div>    
                <img class="image-container" src="10000.png" alt="iter1">
                </div>
		<div>  
                <div class="label"> k_s = 100,000 N/m </div>    
                <img class="image-container" src="100000.png" alt="iter2">
                </div>
            </div> 

	<p class="caption">Varying the spring constant value.
</p>

	<p class="left">In comparing the images it is clear that increasing k_s lowers the elasticity of the cloth. Specifically we see the cloth has less of a bend with higher values of k_s. Which makes sense since the force being exerted downward on the cloth does not change but since we have higher k_s, our acceleration downward and hence our displacement downward later on will decrease. In summary a lower k_s value indicates higher cloth elasticity and higher displacement when the same force is applied.
</p>

<p>Now we change density</p>	
			
<div class='im-container'>
                <div>
                <div class="label"> d = 1 g/cm^2 </div>
                <img class="image-container" src="d1.png" alt="iter0">
                </div>
                <div>  
                <div class="label"> d = 15 g/cm^2 </div>    
                <img class="image-container" src="d15.png" alt="iter1">
                </div>
		<div>  
                <div class="label"> d = 1500 g/cm^2 </div>    
                <img class="image-container" src="d1500.png" alt="iter2">
                </div>
            </div> 

	<p class="caption">Varying the density value.
</p>

	
<p class='left'>We notice that reducing the density reduces the bending effect on the cloth. This is expected and explained again using the relationship of F = ma. Specifically a lower density means that each point mass also has a reduced mass. Now, the external force, in this case gravity remains the same so if we have a reduced mass and the same acceleration, our force itself has been reduced. Since the springs’ physical properties have not been changed, they will displace less compared to before, explaining the lower levels of bending with reduced density. </p>

<p>Now we change damping value</p>	
			
<div class='im-container'>
                <div>
                <div class="label"> damp = 0%</div>
                <img class="image-container" src="0damp.png" alt="iter0">
                </div>
                <div>  
                <div class="label"> damp = .01% </div>    
                <img class="image-container" src="damp.01.png" alt="iter1">
                </div>
		<div>  
                <div class="label"> damp = 1% </div>    
                <img class="image-container" src="1damp.png" alt="iter2">
                </div>
            </div> 

	<p class="caption">Varying the damp percent. Notice how in the first picture with no damping we never reach a steady state due to infinite oscillation. On the opposite end, the last picture with 1% damping, the photo is taken mid flight of the cloth before it reaches to its final resting position. This was to show the slowness with which it reaches the bottom. Similarly the middle photo there is a bit of backward oscillation before reaching the rest state, which is not present in the last photo.
</p>

	<p class='left'>Damping is basically an external factor that we add to simulate energy loss through a variety of physical means for instance friction. When comparing the different simulations on different damping parameters, it was clear that higher damping rates lead to the cloth reaching its steady state position much faster. It also leads to less oscillations before reaching steady state, which makes sense as our forces zero-out much quicker with damping. On the other extreme, having no damping lead to no steady-state being reached; the cloth would continue infinitely moving. With higher damping the cloth also took longer to fall down, which also makes sense since we need to wait for more iterations of fresh gravitational force to move downward. </p>

	<p>Now I show pinned4.json at its default steady state.
</p>	
			
<div class='im-container'>
                <div>
                <div class="label"> Wireframe </div>
                <img class="image-container" src="pinned4wire.png" alt="iter0">
                </div>
                <div>  
                <div class="label"> Normal Shading </div>    
                <img class="image-container" src="pinned4.png" alt="iter1">
                </div>
            </div> 

	<p class="caption">Showing pinned4.json in resting state.
</p>


        </section>

        <section>
            <h3>Part 3: Handling collisions with Other Objects</h3>
		<p>In this part, external collisions were handled, allowing objects to be placed on top of each other and more accurate simulation. The first step in determining whether a collision took place or not is determining if the point-masses ever intersected with the geometry in question. Two intersection tests were implemented, namely intersection against a sphere and intersection with a plane. To implement intersection with a sphere, we just had to check if the point mass’s current position was inside the sphere, so that would mean that the mass collides with the sphere. The plane is a bit more tricky; we need to check if the new position and the last positions of the point mass are on different sides of the plane. If so, that would imply a collision occurred. Once the collision determination has taken place, we need to correctly adjust the position to prevent clipping and make sure that objects are on top of each other and do not go through. This is just done by finding a correction vector that would take the point mass’s location and put it above the surface and not through it and then applying a damping frictional scaling correction of 1-f to that vector. Adding the correction to the last position of the point mass would give the corrected new position for the point-mass, helping us properly implement collision detection and correction.
		</p>
		<p>Below I show scenes from the cloth-sphere intersection varying the spring constant.
		</p>

	<div class='im-container'>
                <div>
                <div class="label">k_s = 500 N/m </div>
                <img class="image-container" src="500k.png" alt="iter0">
                </div>
                <div>  
                <div class="label"> k_s = 5,000 N/m </div>    
                <img class="image-container" src="5000k.png" alt="iter1">
                </div>
		<div>	
                <div class="label">k_s = 50,000 N/m </div>    
                <img class="image-container" src="50000k.png" alt="iter2">
                </div>
            </div> 
	<p class="caption">Comparing the different spring constant values on the steady state of cloth-sphere scene.
</p>
		<p class="left">It is clear as the spring constant increases our cloth looks increasingly stiff as it becomes increasingly inelastic. This stiffness manifests in the appearance over the sphere of the cloth not fully resting on the sphere and instead with higher levels of spring constant value the bottom of the cloth rests higher. This makes sense consider paper, if we rest it on top of a sphere it would act more stiff and not fully take on the ball-like shape. On the other hand if we took a more foldable material like cloth for instance, it could be modeled with lower spring constant value and would more nicely take on the shape of the cloth. </p>

		<p class="left"> Below is the cloth-plane collision scene, helping show the effective implementation of such collision detection. </p>
	
	<div class='im-container'>
                <div>
                <div class="label">Cloth-Plane Intersection </div>
                <img class="image-container" src="planeint.png" alt="flatshading">
                </div>
            </div>
	<p class="caption">The lighter green represents the cloth, which rests on top of the plane, which is colored in the darker green.
</p>
	
        </section>

        <section>
            <h3>Part 4: Handling Self-Collisions</h3>

<p>In this part, I implemented self-collision detection and correction ability. This would basically allow materials to fall on themselves and fold on themselves without having any sort of funky behavior such as artifacts. Detecting self-collisions involves detecting whether two of the point-masses in the array of point-masses that characterize the object we are simulating are close enough to each other, where the “close-enough” property is determined by a threshold quantity. To make the detection of whether a pair of point-masses collide efficient, we had to implement a hash-table data structure which would hold a list of pointmasses. All the pointmasses in a small sub-volume region would get hashed to a common bucket and added to a list of point-masses stored at that bucket. That greatly reduces the number of point-masses we have to compare against to implement the self-collision detection task.  Once the hashing was done and all the point masses were placed in their respective arrays, we would compare all the pointmasses inside the respective arrays. If two were within some threshold distance, (2 * thickness), a correction vector would be applied to the two point masses to get them at this threshold distance apart (creating spacing). Due to the possibility of multiple masses being this close, the final correction would just be the average of all the corrections on the point mass. </p>

<p>The next few pictures show the functionality of working self-collision detection and correction.</p>
		<div class='im-container'>
                <div>
                <div class="label"> Initial Self-Collision </div>
                <img class="image-container" src="earlycol.png" alt="before">
                </div>
                <div>  
                <div class="label"> Large Folds as Cloth Reaches Ground </div>    
                <img class="image-container" src="folding.png" alt="after1">
                </div>
		<div>  
		<div>  
                <div class="label"> Cloth Flattening Out </div>    
                <img class="image-container" src="beginflat.png" alt="after2">
                </div>
		<div> 
		<div>  
                <div class="label"> Late-stage Flattening </div>    
                <img class="image-container" src="later.png" alt="after2">
                </div>
		<div> 
            </div>
		<p class="caption">4 Pictures showing state at different stages of self-collision. Notice how the cloth begins to flatten out and never clips itself due to the self-collision detection functionality. </p>

<p class="left">In the next part I vary k_s and describe the effect it has on the cloth movement.
</p>

	 <div class='im-container'>
                <div>
                <div class="label"> 50 N/m early </div>
                <img class="image-container" src="50early.png" alt="before">
                </div>
                <div>  
                <div class="label"> 50 N/m folding </div>    
                <img class="image-container" src="50fol.png" alt="after1">
                </div>
		<div>  
		<div>  
                <div class="label"> 50 N/m more folding </div>    
                <img class="image-container" src="50fold.png" alt="after2">
                </div>
		<div> 
		<div>  
                <div class="label"> 50 N/m late stage </div>    
                <img class="image-container" src="50late.png" alt="after2">
                </div>
		<div>
                <div class="label"> 50,000 N/m early </div>
                <img class="image-container" src="50000early.png" alt="before">
                </div>
                <div>  
                <div class="label"> 50,000 N/m folding </div>    
                <img class="image-container" src="50000fol.png" alt="after1">
                </div>
		<div>  
		<div>  
                <div class="label"> 50,000 N/m more folding </div>    
                <img class="image-container" src="50000folding.png" alt="after2">
                </div>
		<div> 
		<div>  
                <div class="label"> 50,000 N/m late stage </div>    
                <img class="image-container" src="50000late.png" alt="after2">
                </div>
            </div>
	<p class="caption">Showcasing varying stages of simulation at different spring contants. </p>

      <p class="left"> Clearly a lower k_s value causes more oscillations in the cloth because the cloth itself has a less rigid, more elastic structure baked into it. There are also more self collisions as the point masses themselves move larger distances since forces acting on them are creating larger displacements due to a low k_s value. In the end it leads to a non-steady resting state as well as we see the cloth exhibiting a lot of motion. On the contrary, increasing the k_s value bakes in rigidity to the structure and we see the folds become much more rigid and take up more volume as well. This is due to the fact that the point masses themselves are not moving too much so the correction is pretty large. We see that our steady state also has a sturdy looking fold, which also makes sense through this explanation.
</p>

			<p>Now I vary the density and visualize the effects. 
</p>

	<div class='im-container'>
                <div>
                <div class="label">d = 1g/cm^2 early </div>
                <img class="image-container" src="den1.png" alt="before">
                </div>
                <div>  
                <div class="label">d = 1g/cm^2 folding </div>    
                <img class="image-container" src="den1fol.png" alt="after1">
                </div>
		<div>  
		<div>  
                <div class="label">d = 1g/cm^2 late </div>    
                <img class="image-container" src="den1late.png" alt="after2">
                </div>
		<div> 
		<div>  
                <div class="label">d = 1000g/cm^2 early</div>    
                <img class="image-container" src="den1000early.png" alt="after2">
                </div>
		<div> 
		<div>  
                <div class="label"> d = 1000g/cm^2 folding </div>    
                <img class="image-container" src="den1000.png" alt="after2">
                </div>
		<div> 
		<div>  
                <div class="label">d = 1000g/cm^2 late </div>    
                <img class="image-container" src="den1000fl.png" alt="after2">
                </div>
		<div> 
            </div>

<p class="caption">Showing different stages of simulation for varying density.</p>

<p class="left">In a previous section we established the opposite effects on the simulation that increasing k_s vs increasing the density has. So perhaps it is not very surprising that the effect of the increasing density is the opposite of the effect of increasing k_s on the physical simulation. Specifically, higher density induces larger force amounts due to gravity and hence more collisions since we have more displacements. This leads to a less rigid and more elastic looking simulation with a lot of collisions making it hard to reach a fully steady state and masses will still be oscillating. On the contrary, having a low density value makes our displacements small in comparison leading to a more rigid look of the folds and structure as well. This also leads to corrections looking large in comparison and the overall structure looking more sturdy and less elastic.
</p>
			
        </section>

        <section>
             <h3>Part 5: Shaders</h3>
            <p> The idea behind adaptive sampling is that we can reduce the noise in our rendered images by only stopping sampling once we are confident about the light estimate at the point. Specifically we implement a 95% confidence interval. In implementing this most of the work is in the outermost function: raytrace_pixel. Here is where we take different ray samples to estimate lighting. Basically the idea is as we are taking these ray samples of lighting we accumulate the mean lighting and the standard deviation of the lighting samples. If the mean * 1.96 *(standard deviation of lighting estimate) / sqrt (number of running samples) represents only a 5% of a deviation from our running estimate mean, then we can claim confident convergence of our mean value and assign that to the pixel’s radiance value. One may notice that having to update the current mean and standard deviation of the average is quite an expensive task if done with every ray sample. To mitigate most probably redundant computation, we define a batch size after which we recalculate the estimates and determine convergence. When the batch size is not met we simply keep a streaming count of the current sum of the light samples and the sum of the samples squared because both of these terms help us calculate the end statistics that will lead to convergence. One can also imagine pathological instances where convergence is very tough especially at high frequency locations. In this case we will resort to an absolute maximum number of samples as being the worst-case endpoint for our lighting estimate. Usually this number is quite large since the chance of reaching it is low as convergence will usually be achieved before. 
</p>
<p>
Attached below are two scenes rendered with adaptive sampling with a maximum sample size of 2048.
</p>
            <div class='im-container'>
                <div>
                <div class="label">Bunny Image </div>
                <img class="image-container" src="adapt_bunny.png" alt="tp">
                </div>
                <div>  
                <div class="label"> Bunny Sampling Rate Image</div>    
                <img class="image-container" src="adapt_bunny_rate.png" alt="tpflip">
                </div>
                <div>
                <div class="label"> Spheres Image </div>
                <img class="image-container" src="adapt_balls.png" alt="tpflips">
                </div>
		    <div>
                <div class="label"> Spheres Sampling Rate Image </div>
                <img class="image-container" src="adapt_balls_rate.png" alt="tpflips">
                </div>
            </div>
            <p class="caption">Showing the rendered scenes using adaptive sampling and the associated sample rates. Notice how high frequency areas tend to have higher sampling rates. These images were rendered using depth of 5 and 1 sample per light.
</p>

		
        </section>

        <section>
             <h3>Part 6: Extra Credit</h3>
		<p>For extra credit I implemented two different changes, both to the BVH to make it run faster.</p>
		<h4>Extra Credit 1: Non-Recursive BVH</h4>

        <p>
	The first optimization I did was to implement the BVH using an iterative approach instead of a recursive one. In order to do this, I used a stack and a while loop. Once the stack was empty, I would know that I had finished making the new nodes and the entire BVH structure was ready. When I needed to make new children nodes (when one of the stopping points had not been met yet like too many primitives existing in the bounding box) I would create the two children nodes and then push them to the stack. This is the same thing as creating two children nodes and recursing on them in DFS order but we save the need to create a new function call and instead can do everything inside the original function. One thing that was particularly tough (maybe this would be obvious for someone more adept with C++) was the fact that the fields in the BVH node structure were defined to be constants and initially I was also placing the updated iterators there but that would not work since one can imagine you need to reupdate the iterators as you make downstream edits. I got around this by adding two extra stacks that held the start and end iterators for each of the on-going nodes. I am still not sure if this is the best way to get around the constants but I can imagine right now it is one place that can be updated to make this even faster.
	</p>
		<p>When noticing the difference between recursive implementation and an iterative on, there was a clear around 18% boost in timing performance, with the rate being more accurate for larger renders. </p>
<h4>Extra Credit 2: Surface Area Heuristic for BVH Node Split</h4>
		<p>The second extra credit item I worked on was applying a different heuristic to the split the primitives into two separate nodes. Specifically, I implemented the surface area based split that was introduced in lecture. Specifically we hypothesize that the hit rate of a node is the proportional to the ratio of the surface area of the outer bounding box to the inner bounding box and hence we want to minimize the hit rate to minimize expected hits and the expected time on intersection. Implementing the surface area heuristic was simple, I just needed to add code that added this score and then I compared the split across 3 different axis, x, y, z. I only split on the mean centroid but one could imagine extending this out to also check each partition between the primitives and seeing if the split was better. But given the meshes we were dealing with, I did not think it would make too much of a difference on the end result given the amount of overhead in preprocessing that split. But the surface area split showed significant improvements over the other split I was previously using. Specifically, having a nicely configured split was showcasing around a drop of 40% in the amount of intersection tests per ray (from around 7 on average to 4). This is significant as that has a huge repercussions in reducing the run times of our tracing times.
		</p>

		
        </section>
			
<!-- 
			<table>
                <thead>
                    <tr>
                        <th>Column 1</th>
                        <th>Column 2</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Data 1</td>
                        <td>Data 2</td>
                    </tr>
                    <tr>
                        <td>Data 3</td>
                        <td>Data 4</td>
                    </tr>
                </tbody>
            </table> -->
        
        <!-- Add more sections as needed -->
        
    </div>
</body>
</html>
