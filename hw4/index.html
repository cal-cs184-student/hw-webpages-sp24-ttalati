<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS 184 Homework 4, 
Tanush Talati</title>
    <style>
	.left {
		text-align: left;
	}
        .caption {
            text-align: center;
            font-style: italic;
        }
        .im-container { 
            justify-content: space-between; 
            margin-bottom: -10px;
            flex-wrap: wrap;
            text-align: center;
        }
        .label {
            text-align: center;
        }
        .image-container {
            width: 70%;
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 20px;
            text-align: center;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .image {
            width: 100%;
            margin-bottom: -10px;
        }
        footer {
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            bottom: 0;
            width: 100%;
        }
        h1, h2, h3, h4, h5, h6 {
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <header>
        <h1>CS 184 Homework 4: ClothSim</h1>
        <h2> 
Tanush Talati </h2>
    </header>
    
    <div class="container">
        <h2>Overview</h2>

	<p>
	In this assignment, I implemented a real-time cloth simulator, which relied on a spring-mass based system to physically simulate the movement of physical objects such as cloth. The assignment was split into five parts.
	</p>

	<p>The first part required us to actually build out the grid of springs and masses that represent the cloth. This meant connecting neighboring masses with springs to represent shearing, structural, and bending constraints. Such connections are meant to help get realism into the cloth movement. 
	</p>

	<p>
	In the second part, the structure of connections that were formed was leveraged to actually implement the machinery that would determine the location of the different point masses at different time periods. In other words, it dealt with implementing the simulation component. To do this, first I had to calculate the total force acting on a particular mass. This would be the sum of all the different enabled constraint forces acting on the spring. Next we had to utilize verlet integration, a method to approximate dynamics governed by differential equations to deduce the location and velocity of the point mass at the next time step. Since this method of simulation is unstable in nature, the final step involved bounding the distance of a point mass away from its rest position, which was simply done by checking if it was more that 10% away from its rest position and if it was, we would manually adjust the position to be at the threshold mark.
	</p>
    <p>
	    The third part helped implement a collision detection and handling system. Basically the second part gave a working simulator when only one object existed in the world but with multiple objects, we need to make sure that objects do not go through each other and hence need to detect collisions, because if they occur we can adjust the location of the mass to stay above the collided surface. We only dealt with collisions against two different objects: spheres and planes. The only difference between the two was the process in determining if a collision occurred due to the different geometry of the two surfaces. But after that, if a collision occurred, in both cases a correction vector, allowing the object to stay slightly above the collided point was applied and the new position would be this position scaled by 1 - frictional force.
    </p>
    
    <p>
  The fourth part dealt with self-collisions. This would allow the simulation to exhibit complex geometry such as folding on itself when the cloth is dropped for instance. This was implemented by first creating a hashmap where all masses within a rectangular-prism volume would get hashed into the same key and the value would be a list of the objects in the same volume. Once the hashing was done and all the point masses were placed in their respective arrays, we would compare all the pointmasses inside the respective arrays. If two were within some threshold distance, (2 * thickness), a correction vector would be applied to the two point masses to get them at this threshold distance apart (creating spacing). Due to the possibility of multiple masses being this close, the final correction would just be the average of all the corrections on the point mass. 
    </p>

<p>
The last part was a bit different, it had us implement shaders, a quick way to introduce and implement shading schemes that is relatively computationally cheap. Multiple shaders were implemented. First we started with the basic diffuse shading, where light is reflected equally in all directions. Then, more complex versions were implemented, namely the blinn-phong shading model, texture mapping, displacement and bump-mapping, and environment mapped reflections.
</p>
	    
        <section>
            <h3>Part 1: Masses and Springs</h3>
            
            
            <p>In this part the grid of point masses and the springs that interconnect the various point masses was implemented. This spring-mass representation of the cloth allows us to simulate physics that is used to approximate and simulate realistic cloth movement. The cloth was parameterized by num_width_points and num_height_points, representing the number of masses along the width and height of the cloth respectively. The third dimension was either set to 1 or a random number between -1/1000 and 1/1000 depending on the plane the cloth existed in. Furthermore if a cloth point mass was pinned, hence it would not be moving, that was set as well with a boolean flag.           
            </p>

		<p>Once the grid of point masses was constructed, springs defining the interconnections between the point masses were created. There were three types of spring, representing different constraints: structural, shearing, and bending. Depending on the type of constraint, the spring connected different point masses according to how it was detailed out the spec. Once these mainly bookmarking implementations were complete, a mesh of connections could be seen. These meshes are shown below.
            </p>

		<p>Below is the cloth wireframe showing all the connections both bending and steady behavior.        
            </p>

	    <div class='im-container'>
                <div>
                <div class="label"> Grid-View </div>
                <img class="image-container" src="grid.png" alt="iter0">
                </div>
                <div>  
                <div class="label"> Showing the bending </div>    
                <img class="image-container" src="bending.png" alt="iter1">
                </div>
            </div>

	<p class="caption">Showing the grid view with all three constraints, representing working connection of point-masses using springs.
</p>
<p class="left">
		Now I just show some of the constraints individually.
	</p>

		 <div class='im-container'>
                <div>
                <div class="label"> All Three Constraints </div>
                <img class="image-container" src="three.png" alt="iter0">
                </div>
                <div>  
                <div class="label">Only Shearing Constraints </div>    
                <img class="image-container" src="shearing.png" alt="iter1">
                </div>
		 <div> 
		<div class="label">No Shearing (Bending and Structural) </div>    
                <img class="image-container" src="noshearing.png" alt="iter1">
                </div>
            </div>
			<p class="caption">Showing the connections when turning off some contraints the the view.
</p>
        </section>
        
        <section>
            <h3>Part 2: Simulation via Numerical Integration </h3>
            <p> This section enabled actual cloth simulation. Basically the positions at the next time step, calculated by taking into account the forces exerted on each of the point-masses at the current time-step were calculated using verlet integration. Specifically since the system consists of a lot of interconnected springs, each point mass would have forces being exerted on it by these springs, which can be found out through Hooke’s law. Then applying the rules of dynamics, we know acceleration, mass, and force are related by F = ma, allowing us to find the acceleration and its direction by dividing the force by the mass of the point. Then we can use the equations given my verlet integration to find the new point location of the mass. Doing this point-mass location calculation for all of the pointmasses would help move the grid and give the new position of the cloth. Essentially the new position was calculated as follow x_new = x_old + v_curr * time + a_curr * time^2. And v_curr * time was simply estimated as x_curr - x_old. The exact quantity of time is also dependent on the number of simulation steps per frame and the number of frames per second. Finally since this method of approximation is not stable, we physically bounded the values x could take on. Specifically x could only be at most 10% off its rest position. This would make clothes act more realistically as we know usually it does not move out of place by a large amount.  
	    </p>

		<p>Below are photos showing a working implementation of the cloth simulation, manipulating some of the variables that control the dynamics. 
		</p>

	<div class='im-container'>
                <div>
                <div class="label"> No change default </div>
                <img class="image-container" src="default.png" alt="iter0">
                </div>
            </div> 

		<p class='left'>
		First we change k_s.	
		</p>
       
		<div class='im-container'>
                <div>
                <div class="label"> k_s = 100 N/m </div>
                <img class="image-container" src="100.png" alt="iter0">
                </div>
                <div>  
                <div class="label"> k_s = 10,000 N/m </div>    
                <img class="image-container" src="10000.png" alt="iter1">
                </div>
		<div>  
                <div class="label"> k_s = 100,000 N/m </div>    
                <img class="image-container" src="100000.png" alt="iter2">
                </div>
            </div> 

	<p class="caption">Varying the spring constant value.
</p>

	<p class="left">In comparing the images it is clear that increasing k_s lowers the elasticity of the cloth. Specifically we see the cloth has less of a bend with higher values of k_s. Which makes sense since the force being exerted downward on the cloth does not change but since we have higher k_s, our acceleration downward and hence our displacement downward later on will decrease. In summary a lower k_s value indicates higher cloth elasticity and higher displacement when the same force is applied.
</p>

<p>Now we change density</p>	
			
<div class='im-container'>
                <div>
                <div class="label"> d = 1 g/cm^2 </div>
                <img class="image-container" src="d1.png" alt="iter0">
                </div>
                <div>  
                <div class="label"> d = 15 g/cm^2 </div>    
                <img class="image-container" src="d15.png" alt="iter1">
                </div>
		<div>  
                <div class="label"> d = 1500 g/cm^2 </div>    
                <img class="image-container" src="d1500.png" alt="iter2">
                </div>
            </div> 

	<p class="caption">Varying the density value.
</p>

	
<p class='left'>We notice that reducing the density reduces the bending effect on the cloth. This is expected and explained again using the relationship of F = ma. Specifically a lower density means that each point mass also has a reduced mass. Now, the external force, in this case gravity remains the same so if we have a reduced mass and the same acceleration, our force itself has been reduced. Since the springs’ physical properties have not been changed, they will displace less compared to before, explaining the lower levels of bending with reduced density. </p>

<p>Now we change damping value</p>	
			
<div class='im-container'>
                <div>
                <div class="label"> damp = 0%</div>
                <img class="image-container" src="0damp.png" alt="iter0">
                </div>
                <div>  
                <div class="label"> damp = .01% </div>    
                <img class="image-container" src="damp.01.png" alt="iter1">
                </div>
		<div>  
                <div class="label"> damp = 1% </div>    
                <img class="image-container" src="1damp.png" alt="iter2">
                </div>
            </div> 

	<p class="caption">Varying the damp percent. Notice how in the first picture with no damping we never reach a steady state due to infinite oscillation. On the opposite end, the last picture with 1% damping, the photo is taken mid flight of the cloth before it reaches to its final resting position. This was to show the slowness with which it reaches the bottom. Similarly the middle photo there is a bit of backward oscillation before reaching the rest state, which is not present in the last photo.
</p>

	<p class='left'>Damping is basically an external factor that we add to simulate energy loss through a variety of physical means for instance friction. When comparing the different simulations on different damping parameters, it was clear that higher damping rates lead to the cloth reaching its steady state position much faster. It also leads to less oscillations before reaching steady state, which makes sense as our forces zero-out much quicker with damping. On the other extreme, having no damping lead to no steady-state being reached; the cloth would continue infinitely moving. With higher damping the cloth also took longer to fall down, which also makes sense since we need to wait for more iterations of fresh gravitational force to move downward. </p>

	<p>Now I show pinned4.json at its default steady state.
</p>	
			
<div class='im-container'>
                <div>
                <div class="label"> Wireframe </div>
                <img class="image-container" src="pinned4wire.png" alt="iter0">
                </div>
                <div>  
                <div class="label"> Normal Shading </div>    
                <img class="image-container" src="pinned4.png" alt="iter1">
                </div>
            </div> 

	<p class="caption">Showing pinned4.json in resting state.
</p>


        </section>

        <section>
            <h3>Part 3: Handling collisions with Other Objects</h3>
		<p>In this part, external collisions were handled, allowing objects to be placed on top of each other and more accurate simulation. The first step in determining whether a collision took place or not is determining if the point-masses ever intersected with the geometry in question. Two intersection tests were implemented, namely intersection against a sphere and intersection with a plane. To implement intersection with a sphere, we just had to check if the point mass’s current position was inside the sphere, so that would mean that the mass collides with the sphere. The plane is a bit more tricky; we need to check if the new position and the last positions of the point mass are on different sides of the plane. If so, that would imply a collision occurred. Once the collision determination has taken place, we need to correctly adjust the position to prevent clipping and make sure that objects are on top of each other and do not go through. This is just done by finding a correction vector that would take the point mass’s location and put it above the surface and not through it and then applying a damping frictional scaling correction of 1-f to that vector. Adding the correction to the last position of the point mass would give the corrected new position for the point-mass, helping us properly implement collision detection and correction.
		</p>
		<p>Below I show scenes from the cloth-sphere intersection varying the spring constant.
		</p>

	<div class='im-container'>
                <div>
                <div class="label">k_s = 500 N/m </div>
                <img class="image-container" src="500k.png" alt="iter0">
                </div>
                <div>  
                <div class="label"> k_s = 5,000 N/m </div>    
                <img class="image-container" src="5000k.png" alt="iter1">
                </div>
		<div>	
                <div class="label">k_s = 50,000 N/m </div>    
                <img class="image-container" src="50000k.png" alt="iter2">
                </div>
            </div> 
	<p class="caption">Comparing the different spring constant values on the steady state of cloth-sphere scene.
</p>
		<p class="left">It is clear as the spring constant increases our cloth looks increasingly stiff as it becomes increasingly inelastic. This stiffness manifests in the appearance over the sphere of the cloth not fully resting on the sphere and instead with higher levels of spring constant value the bottom of the cloth rests higher. This makes sense consider paper, if we rest it on top of a sphere it would act more stiff and not fully take on the ball-like shape. On the other hand if we took a more foldable material like cloth for instance, it could be modeled with lower spring constant value and would more nicely take on the shape of the cloth. </p>

		<p class="left"> Below is the cloth-plane collision scene, helping show the effective implementation of such collision detection. </p>
	
	<div class='im-container'>
                <div>
                <div class="label">Cloth-Plane Intersection </div>
                <img class="image-container" src="planeint.png" alt="flatshading">
                </div>
            </div>
	<p class="caption">The lighter green represents the cloth, which rests on top of the plane, which is colored in the darker green.
</p>
	
        </section>

        <section>
            <h3>Part 4: Handling Self-Collisions</h3>

<p>In this part, I implemented self-collision detection and correction ability. This would basically allow materials to fall on themselves and fold on themselves without having any sort of funky behavior such as artifacts. Detecting self-collisions involves detecting whether two of the point-masses in the array of point-masses that characterize the object we are simulating are close enough to each other, where the “close-enough” property is determined by a threshold quantity. To make the detection of whether a pair of point-masses collide efficient, we had to implement a hash-table data structure which would hold a list of pointmasses. All the pointmasses in a small sub-volume region would get hashed to a common bucket and added to a list of point-masses stored at that bucket. That greatly reduces the number of point-masses we have to compare against to implement the self-collision detection task.  Once the hashing was done and all the point masses were placed in their respective arrays, we would compare all the pointmasses inside the respective arrays. If two were within some threshold distance, (2 * thickness), a correction vector would be applied to the two point masses to get them at this threshold distance apart (creating spacing). Due to the possibility of multiple masses being this close, the final correction would just be the average of all the corrections on the point mass. </p>

<p>The next few pictures show the functionality of working self-collision detection and correction.</p>
		<div class='im-container'>
                <div>
                <div class="label"> Initial Self-Collision </div>
                <img class="image-container" src="earlycol.png" alt="before">
                </div>
                <div>  
                <div class="label"> Large Folds as Cloth Reaches Ground </div>    
                <img class="image-container" src="folding.png" alt="after1">
                </div>
		<div>  
		<div>  
                <div class="label"> Cloth Flattening Out </div>    
                <img class="image-container" src="beginflat.png" alt="after2">
                </div>
		<div> 
		<div>  
                <div class="label"> Late-stage Flattening </div>    
                <img class="image-container" src="later.png" alt="after2">
                </div>
		<div> 
            </div>
		<p class="caption">4 Pictures showing state at different stages of self-collision. Notice how the cloth begins to flatten out and never clips itself due to the self-collision detection functionality. </p>

<p class="left">In the next part I vary k_s and describe the effect it has on the cloth movement.
</p>

	 <div class='im-container'>
                <div>
                <div class="label"> 50 N/m early </div>
                <img class="image-container" src="50early.png" alt="before">
                </div>
                <div>  
                <div class="label"> 50 N/m folding </div>    
                <img class="image-container" src="50fol.png" alt="after1">
                </div>
		<div>  
		<div>  
                <div class="label"> 50 N/m more folding </div>    
                <img class="image-container" src="50fold.png" alt="after2">
                </div>
		<div> 
		<div>  
                <div class="label"> 50 N/m late stage </div>    
                <img class="image-container" src="50late.png" alt="after2">
                </div>
		<div>
                <div class="label"> 50,000 N/m early </div>
                <img class="image-container" src="50000early.png" alt="before">
                </div>
                <div>  
                <div class="label"> 50,000 N/m folding </div>    
                <img class="image-container" src="50000fol.png" alt="after1">
                </div>
		<div>  
		<div>  
                <div class="label"> 50,000 N/m more folding </div>    
                <img class="image-container" src="50000folding.png" alt="after2">
                </div>
		<div> 
		<div>  
                <div class="label"> 50,000 N/m late stage </div>    
                <img class="image-container" src="50000late.png" alt="after2">
                </div>
            </div>
	<p class="caption">Showcasing varying stages of simulation at different spring contants. </p>

      <p class="left"> Clearly a lower k_s value causes more oscillations in the cloth because the cloth itself has a less rigid, more elastic structure baked into it. There are also more self collisions as the point masses themselves move larger distances since forces acting on them are creating larger displacements due to a low k_s value. In the end it leads to a non-steady resting state as well as we see the cloth exhibiting a lot of motion. On the contrary, increasing the k_s value bakes in rigidity to the structure and we see the folds become much more rigid and take up more volume as well. This is due to the fact that the point masses themselves are not moving too much so the correction is pretty large. We see that our steady state also has a sturdy looking fold, which also makes sense through this explanation.
</p>

			<p>Now I vary the density and visualize the effects. 
</p>

	<div class='im-container'>
                <div>
                <div class="label">d = 1g/cm^2 early </div>
                <img class="image-container" src="den1.png" alt="before">
                </div>
                <div>  
                <div class="label">d = 1g/cm^2 folding </div>    
                <img class="image-container" src="den1fol.png" alt="after1">
                </div>
		<div>  
		<div>  
                <div class="label">d = 1g/cm^2 late </div>    
                <img class="image-container" src="den1late.png" alt="after2">
                </div>
		<div> 
		<div>  
                <div class="label">d = 1000g/cm^2 early</div>    
                <img class="image-container" src="den1000early.png" alt="after2">
                </div>
		<div> 
		<div>  
                <div class="label"> d = 1000g/cm^2 folding </div>    
                <img class="image-container" src="den1000.png" alt="after2">
                </div>
		<div> 
		<div>  
                <div class="label">d = 1000g/cm^2 late </div>    
                <img class="image-container" src="den1000fl.png" alt="after2">
                </div>
		<div> 
            </div>

<p class="caption">Showing different stages of simulation for varying density.</p>

<p class="left">In a previous section we established the opposite effects on the simulation that increasing k_s vs increasing the density has. So perhaps it is not very surprising that the effect of the increasing density is the opposite of the effect of increasing k_s on the physical simulation. Specifically, higher density induces larger force amounts due to gravity and hence more collisions since we have more displacements. This leads to a less rigid and more elastic looking simulation with a lot of collisions making it hard to reach a fully steady state and masses will still be oscillating. On the contrary, having a low density value makes our displacements small in comparison leading to a more rigid look of the folds and structure as well. This also leads to corrections looking large in comparison and the overall structure looking more sturdy and less elastic.
</p>
			
        </section>

        <section>
             <h3>Part 5: Shaders</h3>
            <p> In the last part, we were tasked with implementing many different types of shaders. Essentially shaders are parallel programs that are executed inside a GPU allowing for fast parallel computation of things such as lighting at various pixels in addition to other portions of the entire graphics pipeline. In this manner we can get over the computational complexity of being able to produce realistic lighting for real-time applications that run at high framerates. We specifically worked with GLSL shader programs. Specifically at a high level shader programs consists of attributes, which are inputs to the specific vertex shader being implemented; uniform, global variables and properties such as transform matrices that are shared by all instances of the program; and varying which are basically inputs passed into from vertex shaders into fragment shaders. Along with these types, there are two types of shaders: vertex and fragment. Vertex shaders usually deal with applying transformations to vertices and modifying the geometry of our scene, writing it out to gl_Position. Once the vertex manipulation is complete, and any varyings are written, the fragment shader becomes of importance. The fragment shader processes the post-rasterization fragments. Along with these fragments and properties calculated in the vertex shaders, color is assigned using some shading function that is defined in these fragment shaders and written out to out_color. Using this general technique of having .frag and .vert files, many different shading functions were implemented in this part. 
</p>
<p>
The first shader implement was simple diffuse shading, in which the color at a specific point (v, which was passed in through the vertex shader) is a function of the distance away from the light source and the cosine angle with respect to the surface normal of the surface in question. The intensity scales with I/r^2 where r  is the distance away from the light source and I is the intensity. We also multiply this with the cosine angle as well as a constant that is just used for empirical adjustment.  
</p>
            <div class='im-container'>
                <div>
                <div class="label">Diffuse Shading </div>
                <img class="image-container" src="diffuse.png" alt="tp">
                </div>
            </div>
            <p class="caption">Showing Diffuse shading only.
</p>
		<p class="left"> Using the toy built from the diffuse shading, Blinn-Phong Shading was implemented. In Blinn-Phong Shading, we try to produce realistic lighting by creating a light model. Specifically we say that the light emitted in a scene consists of the summation of ambient light, diffuse lighting, and specular lighting. Ambient light is just light that exists in the environment (this would be more accurate if we used global light illumination for instance, but we can just estimate by having a base level of light in the environment). Diffuse lighting is the light that the surface reflects, which in this case we are saying has a diffuse property so an equal amount is reflected in all directions. This component is the same in terms of code as the diffuse only shader implemented in the previous part. Finally specular light is lighting that has to do with reflection of the direct light source, giving a shiny concentrated light appearance. The estimate uses the angle between the half vector of the source to the camera and the surface normal along with a scaling factor of p, which we raise the cosine of the angle to to determine the specular intensity. It is also multiplied by the intensity and falls off with a factor of r^2. Just like with the ambient lighting, we multiply with a constant just to get good empirical results. In summary the lighting estimate is given by this equation: L = k_a I_a + k_d (I/r^2) /max(0, n dot  l) + k_s (I/r^2) max(0, n dot h)^p (dot represents dot product operator which is the same as calculating cosine of the angle between the two vectors. With good constants we can get pretty realistic images and shading at the fraction of the cost of alternative methods such as path tracing, allowing us to scale with realtime rendering demands. 
</p>
		<p>Attached are working Blinn-Phong model renders.
</p>
 <div class='im-container'>
                <div>
                <div class="label">Blinn-Plong: All 3 components</div>
                <img class="image-container" src="phongall.png" alt="tp">
                </div>
	 	<div>
                <div class="label">Blinn-Plong: Ambient Only</div>
                <img class="image-container" src="phongam.png" alt="tp">
                </div>
		 <div>
                <div class="label">Blinn-Plong: Diffuse Only</div>
                <img class="image-container" src="phongdiffuse.png" alt="tp">
                </div>
	 	<div>
                <div class="label">Blinn-Plong: Specular Only</div>
                <img class="image-container" src="phongspec.png" alt="tp">
                </div>
		 <div>
                <div class="label">Blinn-Plong: Specular on Sphere (better view)</div>
                <img class="image-container" src="specsphere.png" alt="tp">
                </div>
            </div>
            <p class="caption">Showing the different components of Blinn-Phong shading </p>

		<p class="left">Next I implemented texture mapping, which mainly involved just calling the texture sample function on the correct texture map. The attached photo shows a custom texture map on the sphere-cloth system (it's the spiderman meme).</p>
		<div class='im-container'>
                <div>
                <div class="label">Raw Texture</div>
                <img class="image-container" src="tex.png" alt="tp">
                </div>
	 	<div>
                <div class="label">Texture Mapping Render</div>
                <img class="image-container" src="texture.png" alt="tp">
                </div>
            </div>
		  <p class="caption">Functional texture-mapping showcased through the custom texture map of the popular spider-man meme. </p>

		<p class="left"> The next part involved displacement and bump mapping. Basically in bum mapping the vertex normals were adjusted using a heightmap function, which would basically give offsets with which the direction of the normal would be adjusted. This was then converted to and from object coordinates into the world coordinate to give the new normal location for each vertex. Essentially the normal at each vertex that was inputted was adjusted as a function of the position and the height map at each position. With the new adjusted normal, it gives the illusion of bumps on the surface since ideally the height map is a function of some property in the shape, in my case I just used the color attribute and scaled it up. Then using the adjusted normal into the Blinn-Phong Shading model would give an adjusted color. When noticing the final rendering we see shading in a way that makes it seem that the object is not smooth even though the actual object itself did not move its vertex locations. 
</p> 
		<p class="left">On the contrary, when implementing displacement mapping, we did the same new normal calculation as before, however we also preadjusted the locations of the actual vertex. In other words, we also made the surface artificially rough by changing the locations of the vertex. The change in location was once again a function of position and a height map. Similar to before I used the color property at each vertex location as an output to the height map query. Now the geometry of the shape is also rough/non-smooth along with more pronounced bumps seen on the surface since we have bumps induced both by the artificial bump shading as well as actual bumps on the surface of the object.</p>

		<p class='left'> Comparing bump and displacement mapping images using texture_3 (not default texture_2)</p>
		<div class='im-container'>
                <div>
                <div class="label">Bump Mapping: Sphere</div>
                <img class="image-container" src="bumpsphere.png" alt="tp">
                </div>
	 	<div>
                <div class="label">Bump Mapping: Cloth</div>
                <img class="image-container" src="bumpcloth.png" alt="tp">
                </div>
		<div>
                <div class="label">Bump Mapping: Sphere and Cloth</div>
                <img class="image-container" src="bumpsc.png" alt="tp">
                </div>
		<div>
                <div class="label">Displacement Mapping: Cloth</div>
                <img class="image-container" src="dissc.png" alt="tp">
                </div>
		<div>
                <div class="label">Displacement Mapping: Sphere</div>
                <img class="image-container" src="diss.png" alt="tp">
                </div>
		<div>
                <div class="label">Displacement Mapping: Sphere and Cloth</div>
                <img class="image-container" src="dissb.png" alt="tp">
                </div>	
            </div>
 	 <p class="caption">Clearly we see the surface itself is rough and has actual bumps when using displacement mapping, whereas the bumps only are an artifact of the adjusted sampled normals in bump mapping. </p>

		<p class="left"> In comparing the results of bump and displacement mapping, it is clear that displacement mapping has a much more rough and coarse look. This is due to the fact that displacement mapping actually changes the geometry of the shape as well as the fact that it samples the color to place at each fragment based on the protruded normal from the surface. Therefore, in bump mapping we are essentially altering our surface normal twice: first while shifting the surface and second while sampling a color when trying to color the fragments. On the contrary, we see that bump mapping does give us a feeling that the shape is rough but also has a very smooth shape outline; the roughness is only on the mapped texture. This makes sense since we did not actually change the positions of the vertices, giving less of a rough and coarse look compared to displacement mapping.
</p>
		<p class="left"> Next I compare changing the mesh resolution on the effects on the bump and displacement mapping.</p>
	<div class='im-container'>
                <div>
                <div class="label">Bump Mapping: -o 16 -a 16 </div>
                <img class="image-container" src="sphere16.png" alt="tp">
                </div>
	 	<div>
                <div class="label">Bump Mapping: -o 128 -a 128</div>
                <img class="image-container" src="sphere128.png" alt="tp">
                </div>
		<div>
                <div class="label">Displacement Mapping: -o 16 -a 16</div>
                <img class="image-container" src="diss16.png" alt="tp">
                </div>
		<div>
                <div class="label">Displacement Mapping: -o 128 -a 128</div>
                <img class="image-container" src="diss128.png" alt="tp">
                </div>
		</div>
		
			 <p class="caption">Effect of mesh resolution on bump and displacement mapping </p>

		<p>
Evidently with a more coarse mesh representation of the sphere our displacement mapped results look even more exaggeratedly coarse and out of the spherical shape. This makes sense as there are less points so each point we shift we are making the overall shape even less spherical and there are few points to begin with so only some points out of phase cause it to look less spherical. The shape does look more spherical at the higher 128 mesh resolution, which is also expected using the same rationale as above. On the other hand, bump mapping still maintains the spherical look, which makes sense as we are not actually changing the geometry of the shape and it also seems like have a lower resolution mesh did not affect the resolution of the texture that got mapped to the surface in both cases as well probably because the texture image may have been scaled or is small to begin with. 
</p>
		<p>The final shader that needed to be implemented was environment-mapped reflections. Basically we needed light to be reflected. This was done by simply updating the fragment file and sampling the cube texture at the incoming direction which was calculated by subtracting the outgoing direction from twice the direction of the surface normal. 
</p>
		<p>Attached are the photos of the working mirror shader.</p>
		<div class='im-container'>
                <div>
                <div class="label">Sphere</div>
                <img class="image-container" src="mirrorball.png" alt="tp">
                </div>
	 	<div>
                <div class="label">Cloth</div>
                <img class="image-container" src="mirrorcloth.png" alt="tp">
                </div>
		<div>
                <div class="label">Sphere and Cloth</div>
                <img class="image-container" src="mirrorb.png" alt="tp">
                </div>
		</div>
		<p class='caption'>Working Environment-mapped reflection.</p>
        </section>

        <section>
             <h3>Part 6: Extra Credit</h3>
		
        </section>
			
<!-- 
			<table>
                <thead>
                    <tr>
                        <th>Column 1</th>
                        <th>Column 2</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Data 1</td>
                        <td>Data 2</td>
                    </tr>
                    <tr>
                        <td>Data 3</td>
                        <td>Data 4</td>
                    </tr>
                </tbody>
            </table> -->
        
        <!-- Add more sections as needed -->
        
    </div>
</body>
</html>
